"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MemKVStore = exports.DynamoDBStore = exports.SharpBufferStore = exports.NullStore = exports.S3Store = exports.LocalStore = void 0;
const fs = require("fs");
const path = require("path");
const DynamoDB = require("aws-sdk/clients/dynamodb");
const S3 = require("aws-sdk/clients/s3");
const config_1 = require("./config");
;
/**
 * A local file system based store.
 */
class LocalStore {
    constructor(root = '') {
        this.root = root;
    }
    async get(p, _) {
        p = path.join(this.root, p);
        return {
            buffer: await fs.promises.readFile(p),
            type: filetype(p),
            headers: {
                'Etag': 'fake-etag',
                'Last-Modified': 'Wed, 21 Oct 2014 07:28:00 GMT',
                'Cache-Control': 'max-age',
            },
        };
    }
    async url(p) {
        return Promise.resolve(path.join(this.root, p));
    }
}
exports.LocalStore = LocalStore;
/**
 * S3 based store.
 */
class S3Store {
    constructor(bucket) {
        this.bucket = bucket;
        this._s3 = new S3({ region: config_1.default.region });
    }
    async get(p, beforeGetFunc) {
        var _a;
        beforeGetFunc === null || beforeGetFunc === void 0 ? void 0 : beforeGetFunc();
        const res = await this._s3.getObject({
            Bucket: this.bucket,
            Key: p,
        }).promise();
        if (Buffer.isBuffer(res.Body)) {
            const headers = {};
            if (res.ETag) {
                headers.Etag = res.ETag;
            }
            if (res.LastModified) {
                headers['Last-Modified'] = res.LastModified;
            }
            if (res.CacheControl) {
                headers['Cache-Control'] = res.CacheControl;
            }
            return {
                buffer: res.Body,
                type: (_a = res.ContentType) !== null && _a !== void 0 ? _a : '',
                headers,
            };
        }
        ;
        throw new Error('S3 response body is not a Buffer type');
    }
    async url(p) {
        return this._s3.getSignedUrlPromise('getObject', {
            Bucket: this.bucket,
            Key: p,
            Expires: 1200,
        });
    }
}
exports.S3Store = S3Store;
/**
 * A fake store. Only for unit test.
 */
class NullStore {
    url(_) {
        throw new Error('Method not implemented.');
    }
    async get(p, _) {
        return Promise.resolve({
            buffer: Buffer.from(p),
            type: '',
            headers: {},
        });
    }
}
exports.NullStore = NullStore;
/**
 * A sharp image store. Only for unit test.
 */
class SharpBufferStore {
    constructor(image) {
        this.image = image;
    }
    url(_) {
        throw new Error('Method not implemented.');
    }
    async get(_, __) {
        const { data, info } = await this.image.toBuffer({ resolveWithObject: true });
        return { buffer: data, type: info.format, headers: {} };
    }
}
exports.SharpBufferStore = SharpBufferStore;
class DynamoDBStore {
    constructor(tableName) {
        this.tableName = tableName;
        this._ddb = new DynamoDB.DocumentClient({ region: config_1.default.region });
    }
    url(_) {
        throw new Error('Method not implemented.');
    }
    async get(key, _) {
        var _a;
        const data = await this._ddb.get({
            TableName: this.tableName,
            Key: { id: key },
        }).promise();
        return (_a = data.Item) !== null && _a !== void 0 ? _a : {};
    }
}
exports.DynamoDBStore = DynamoDBStore;
class MemKVStore {
    constructor(dict) {
        this.dict = dict;
    }
    url(_) {
        throw new Error('Method not implemented.');
    }
    async get(key, _) {
        var _a;
        return Promise.resolve((_a = this.dict[key]) !== null && _a !== void 0 ? _a : {});
    }
}
exports.MemKVStore = MemKVStore;
function filetype(file) {
    return path.extname(file).substring(1);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RvcmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvc3RvcmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUM3QixxREFBcUQ7QUFDckQseUNBQXlDO0FBRXpDLHFDQUE4QjtBQTBCMkUsQ0FBQztBQUkxRzs7R0FFRztBQUNILE1BQWEsVUFBVTtJQUNyQixZQUEyQixPQUFlLEVBQUU7UUFBakIsU0FBSSxHQUFKLElBQUksQ0FBYTtJQUFJLENBQUM7SUFDMUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFTLEVBQUUsQ0FBYztRQUV4QyxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQzVCLE9BQU87WUFDTCxNQUFNLEVBQUUsTUFBTSxFQUFFLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7WUFDckMsSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUM7WUFDakIsT0FBTyxFQUFFO2dCQUNQLE1BQU0sRUFBRSxXQUFXO2dCQUNuQixlQUFlLEVBQUUsK0JBQStCO2dCQUNoRCxlQUFlLEVBQUUsU0FBUzthQUMzQjtTQUNGLENBQUM7SUFDSixDQUFDO0lBRU0sS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFTO1FBQ3hCLE9BQU8sT0FBTyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNsRCxDQUFDO0NBQ0Y7QUFuQkQsZ0NBbUJDO0FBRUQ7O0dBRUc7QUFDSCxNQUFhLE9BQU87SUFFbEIsWUFBbUMsTUFBYztRQUFkLFdBQU0sR0FBTixNQUFNLENBQVE7UUFEekMsUUFBRyxHQUFPLElBQUksRUFBRSxDQUFDLEVBQUUsTUFBTSxFQUFFLGdCQUFNLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQztJQUNDLENBQUM7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TSxFQUFFLENBQUMsQ0FBQztJQUNkLENBQUM7SUFDbEQsR0FBRyxDQUFDLENBQVM7UUFDbEIsTUFBTSxJQUFJLEtBQUssQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO0lBQzdDLENBQUM7SUFDTSxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQVcsRUFBRSxDQUFjOztRQUMxQyxNQUFNLElBQUksR0FBRyxNQUFNLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDO1lBQy9CLFNBQVMsRUFBRSxJQUFJLENBQUMsU0FBUztZQUN6QixHQUFHLEVBQUUsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFO1NBQ2pCLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUNiLE9BQU8sTUFBQSxJQUFJLENBQUMsSUFBSSxtQ0FBSSxFQUFFLENBQUM7SUFDekIsQ0FBQztDQUNGO0FBYkQsc0NBYUM7QUFFRCxNQUFhLFVBQVU7SUFDckIsWUFBbUMsSUFBZTtRQUFmLFNBQUksR0FBSixJQUFJLENBQVc7SUFBSSxDQUFDO0lBQ2hELEdBQUcsQ0FBQyxDQUFTO1FBQ2xCLE1BQU0sSUFBSSxLQUFLLENBQUMseUJBQXlCLENBQUMsQ0FBQztJQUM3QyxDQUFDO0lBRU0sS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFXLEVBQUUsQ0FBYzs7UUFDMUMsT0FBTyxPQUFPLENBQUMsT0FBTyxDQUFDLE1BQUEsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsbUNBQUksRUFBRSxDQUFDLENBQUM7SUFDL0MsQ0FBQztDQUNGO0FBVEQsZ0NBU0M7QUFHRCxTQUFTLFFBQVEsQ0FBQyxJQUFZO0lBQzVCLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDekMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgKiBhcyBEeW5hbW9EQiBmcm9tICdhd3Mtc2RrL2NsaWVudHMvZHluYW1vZGInO1xuaW1wb3J0ICogYXMgUzMgZnJvbSAnYXdzLXNkay9jbGllbnRzL3MzJztcbmltcG9ydCAqIGFzIHNoYXJwIGZyb20gJ3NoYXJwJztcbmltcG9ydCBjb25maWcgZnJvbSAnLi9jb25maWcnO1xuaW1wb3J0IHsgSUh0dHBIZWFkZXJzIH0gZnJvbSAnLi9wcm9jZXNzb3InO1xuXG4vKipcbiAqIEEgYWJzdHJhY3Qgc3RvcmUgdG8gZ2V0IGZpbGUgZGF0YS5cbiAqIEl0IGNhbiBlaXRoZXIgZ2V0IGZyb20gczMgb3IgbG9jYWwgZmlsZXN5c3RlbS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJU3RvcmU8VD4ge1xuXG4gIC8qKlxuICAgKiBSZWFkIGFsbCBidWZmZXIgZnJvbSB1bmRlcmx5aW5nLlxuICAgKiBSZXR1cm4gYm90aCB0aGUgYnVmZmVyIGFuZCB0aGUgczMgb2JqZWN0L2ZpbGUgdHlwZS5cbiAgICogVXN1YWxseSB0aGUgZmlsZSB0eXBlIGlzIHRoZSBmaWxlJ3Mgc3VmZml4LlxuICAgKlxuICAgKiBAcGFyYW0gcCB0aGUgcGF0aCBvZiB0aGUgczMgb2JqZWN0IG9yIHRoZSBmaWxlXG4gICAqIEBwYXJhbSBiZWZvcmVHZXRGdW5jIGEgaG9vayBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYmVmb3JlIGdldFxuICAgKi9cbiAgZ2V0KHA6IHN0cmluZywgYmVmb3JlR2V0RnVuYz86ICgpID0+IHZvaWQpOiBQcm9taXNlPFQ+O1xuXG4gIHVybChwOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUtleVZhbHVlIHtcbiAgW2tleTogc3RyaW5nXTogYW55O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElCdWZmZXJTdG9yZSBleHRlbmRzIElTdG9yZTx7IGJ1ZmZlcjogQnVmZmVyOyB0eXBlOiBzdHJpbmc7IGhlYWRlcnM6IElIdHRwSGVhZGVycyB9PiB7IH07XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUtWU3RvcmUgZXh0ZW5kcyBJU3RvcmU8SUtleVZhbHVlPiB7IH1cblxuLyoqXG4gKiBBIGxvY2FsIGZpbGUgc3lzdGVtIGJhc2VkIHN0b3JlLlxuICovXG5leHBvcnQgY2xhc3MgTG9jYWxTdG9yZSBpbXBsZW1lbnRzIElCdWZmZXJTdG9yZSB7XG4gIHB1YmxpYyBjb25zdHJ1Y3Rvcihwcml2YXRlIHJvb3Q6IHN0cmluZyA9ICcnKSB7IH1cbiAgcHVibGljIGFzeW5jIGdldChwOiBzdHJpbmcsIF8/OiAoKSA9PiB2b2lkKTpcbiAgUHJvbWlzZTx7IGJ1ZmZlcjogQnVmZmVyOyB0eXBlOiBzdHJpbmc7IGhlYWRlcnM6IElIdHRwSGVhZGVycyB9PiB7XG4gICAgcCA9IHBhdGguam9pbih0aGlzLnJvb3QsIHApO1xuICAgIHJldHVybiB7XG4gICAgICBidWZmZXI6IGF3YWl0IGZzLnByb21pc2VzLnJlYWRGaWxlKHApLFxuICAgICAgdHlwZTogZmlsZXR5cGUocCksXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdFdGFnJzogJ2Zha2UtZXRhZycsXG4gICAgICAgICdMYXN0LU1vZGlmaWVkJzogJ1dlZCwgMjEgT2N0IDIwMTQgMDc6Mjg6MDAgR01UJyxcbiAgICAgICAgJ0NhY2hlLUNvbnRyb2wnOiAnbWF4LWFnZScsXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgdXJsKHA6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwYXRoLmpvaW4odGhpcy5yb290LCBwKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBTMyBiYXNlZCBzdG9yZS5cbiAqL1xuZXhwb3J0IGNsYXNzIFMzU3RvcmUgaW1wbGVtZW50cyBJQnVmZmVyU3RvcmUge1xuICBwcml2YXRlIF9zMzogUzMgPSBuZXcgUzMoeyByZWdpb246IGNvbmZpZy5yZWdpb24gfSk7XG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgYnVja2V0OiBzdHJpbmcpIHsgfVxuICBwdWJsaWMgYXN5bmMgZ2V0KHA6IHN0cmluZywgYmVmb3JlR2V0RnVuYz86ICgpID0+IHZvaWQpOlxuICBQcm9taXNlPHsgYnVmZmVyOiBCdWZmZXI7IHR5cGU6IHN0cmluZzsgaGVhZGVyczogSUh0dHBIZWFkZXJzIH0+IHtcbiAgICBiZWZvcmVHZXRGdW5jPy4oKTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9zMy5nZXRPYmplY3Qoe1xuICAgICAgQnVja2V0OiB0aGlzLmJ1Y2tldCxcbiAgICAgIEtleTogcCxcbiAgICB9KS5wcm9taXNlKCk7XG5cbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHJlcy5Cb2R5KSkge1xuICAgICAgY29uc3QgaGVhZGVyczogSUh0dHBIZWFkZXJzID0ge307XG4gICAgICBpZiAocmVzLkVUYWcpIHsgaGVhZGVycy5FdGFnID0gcmVzLkVUYWc7IH1cbiAgICAgIGlmIChyZXMuTGFzdE1vZGlmaWVkKSB7IGhlYWRlcnNbJ0xhc3QtTW9kaWZpZWQnXSA9IHJlcy5MYXN0TW9kaWZpZWQ7IH1cbiAgICAgIGlmIChyZXMuQ2FjaGVDb250cm9sKSB7IGhlYWRlcnNbJ0NhY2hlLUNvbnRyb2wnXSA9IHJlcy5DYWNoZUNvbnRyb2w7IH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJ1ZmZlcjogcmVzLkJvZHkgYXMgQnVmZmVyLFxuICAgICAgICB0eXBlOiByZXMuQ29udGVudFR5cGUgPz8gJycsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICB9O1xuICAgIH07XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTMyByZXNwb25zZSBib2R5IGlzIG5vdCBhIEJ1ZmZlciB0eXBlJyk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgdXJsKHA6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgcmV0dXJuIHRoaXMuX3MzLmdldFNpZ25lZFVybFByb21pc2UoJ2dldE9iamVjdCcsIHtcbiAgICAgIEJ1Y2tldDogdGhpcy5idWNrZXQsXG4gICAgICBLZXk6IHAsXG4gICAgICBFeHBpcmVzOiAxMjAwLFxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogQSBmYWtlIHN0b3JlLiBPbmx5IGZvciB1bml0IHRlc3QuXG4gKi9cbmV4cG9ydCBjbGFzcyBOdWxsU3RvcmUgaW1wbGVtZW50cyBJQnVmZmVyU3RvcmUge1xuICBwdWJsaWMgdXJsKF86IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IGltcGxlbWVudGVkLicpO1xuICB9XG4gIHB1YmxpYyBhc3luYyBnZXQocDogc3RyaW5nLCBfPzogKCkgPT4gdm9pZCk6IFByb21pc2U8eyBidWZmZXI6IEJ1ZmZlcjsgdHlwZTogc3RyaW5nOyBoZWFkZXJzOiBJSHR0cEhlYWRlcnMgfT4ge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgYnVmZmVyOiBCdWZmZXIuZnJvbShwKSxcbiAgICAgIHR5cGU6ICcnLFxuICAgICAgaGVhZGVyczoge30sXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBIHNoYXJwIGltYWdlIHN0b3JlLiBPbmx5IGZvciB1bml0IHRlc3QuXG4gKi9cbmV4cG9ydCBjbGFzcyBTaGFycEJ1ZmZlclN0b3JlIGltcGxlbWVudHMgSUJ1ZmZlclN0b3JlIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBpbWFnZTogc2hhcnAuU2hhcnApIHsgfVxuICBwdWJsaWMgdXJsKF86IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IGltcGxlbWVudGVkLicpO1xuICB9XG5cbiAgYXN5bmMgZ2V0KF86IHN0cmluZywgX18/OiAoKSA9PiB2b2lkKTogUHJvbWlzZTx7IGJ1ZmZlcjogQnVmZmVyOyB0eXBlOiBzdHJpbmc7IGhlYWRlcnM6IElIdHRwSGVhZGVycyB9PiB7XG4gICAgY29uc3QgeyBkYXRhLCBpbmZvIH0gPSBhd2FpdCB0aGlzLmltYWdlLnRvQnVmZmVyKHsgcmVzb2x2ZVdpdGhPYmplY3Q6IHRydWUgfSk7XG4gICAgcmV0dXJuIHsgYnVmZmVyOiBkYXRhLCB0eXBlOiBpbmZvLmZvcm1hdCwgaGVhZGVyczoge30gfTtcbiAgfVxufVxuXG5cbmV4cG9ydCBjbGFzcyBEeW5hbW9EQlN0b3JlIGltcGxlbWVudHMgSUtWU3RvcmUge1xuICBwcml2YXRlIF9kZGIgPSBuZXcgRHluYW1vREIuRG9jdW1lbnRDbGllbnQoeyByZWdpb246IGNvbmZpZy5yZWdpb24gfSk7XG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgdGFibGVOYW1lOiBzdHJpbmcpIHsgfVxuICBwdWJsaWMgdXJsKF86IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IGltcGxlbWVudGVkLicpO1xuICB9XG4gIHB1YmxpYyBhc3luYyBnZXQoa2V5OiBzdHJpbmcsIF8/OiAoKSA9PiB2b2lkKTogUHJvbWlzZTxJS2V5VmFsdWU+IHtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5fZGRiLmdldCh7XG4gICAgICBUYWJsZU5hbWU6IHRoaXMudGFibGVOYW1lLFxuICAgICAgS2V5OiB7IGlkOiBrZXkgfSxcbiAgICB9KS5wcm9taXNlKCk7XG4gICAgcmV0dXJuIGRhdGEuSXRlbSA/PyB7fTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTWVtS1ZTdG9yZSBpbXBsZW1lbnRzIElLVlN0b3JlIHtcbiAgcHVibGljIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSBkaWN0OiBJS2V5VmFsdWUpIHsgfVxuICBwdWJsaWMgdXJsKF86IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IGltcGxlbWVudGVkLicpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGdldChrZXk6IHN0cmluZywgXz86ICgpID0+IHZvaWQpOiBQcm9taXNlPElLZXlWYWx1ZT4ge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5kaWN0W2tleV0gPz8ge30pO1xuICB9XG59XG5cblxuZnVuY3Rpb24gZmlsZXR5cGUoZmlsZTogc3RyaW5nKSB7XG4gIHJldHVybiBwYXRoLmV4dG5hbWUoZmlsZSkuc3Vic3RyaW5nKDEpO1xufSJdfQ==